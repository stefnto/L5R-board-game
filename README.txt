Η εκπόνηση της εργασίας έχει γίνει απο τους:
α)Δουκάκη-Χιώτη Στέφανο, ΑΜ: 1115201800276
β)Μάλλιο Απόστολο, ΑΜ: 1115201800103

Έχουμε δημιουργήσει ένα makefile αρχείο που μεταγλωττεί τα αρχεία και δημιουργεί το εκτελέσιμο με όνομα project.

Στη main συνάρτηση στο main.cpp έχουμε ορίσει να παίζουν 3 παίκτες το παιχνίδι, το οποίο μπορεί να αλλάξει αλλάζοντας τιμή στην μεταβλητή players.
Κατα τη δημιουργία του GameBoard και την initializeGameBoard(), οι παίκτες τραβάν απο 4 πράσινες κάρτες στο χέρι τους για να ξεκινήσουν το παιχνίδι.
Στην αρχή κάθε γύρου ο κάθε παίκτης παίρνει 5 μονάδες χρημάτων(που προερχονται απο το stronghold), και έπειτα τραβάνε 4 μαύρες κάρτες που αποτελούν τις επαρχίες.
Ως σχεδιαστική επιλογή, επειδή κάθε παίκτης παίρνει 5 μονάδες χρημάτων απο το stronghold(χωρίς να γίνεται αυτό tap) στην αρχή κάθε γύρου, αν θέλει να το χρησιμοποιήσει ξανά για να πάρει λεφτά (temp_money, ουσιαστικά κατά τη λειτουργία της harvest()),
το stronghold θα του επιφέρει 2 μονάδες χρημάτων, θα γίνει tap, και δεν θα μπορεί να ξαναχρησιμοποιηθεί για το υπόλοιπο του γύρου.
Η sortplayers() κατατάσσει τους παίκτες σε φθίνουσα σειρά εντιμότητας στον πίνακα στον οποίο αποθηκεύονται.
Το stronghold του κάθε παίκτη που του αποδίδει την εντιμότητα, σε κάθε παιχνίδι έχει τυχαία εντιμότητα ανάμεσα στο 0 και στον αριθμό των παικτών σε κάθε παιχνίδι. 
Αν δύο παίκτες έχουν την ίδια εντιμότητα, πρώτος θα παίξει ο παίκτης που δημιουργήθηκε πρώτος.
Οι παίκτες παίζουν την κάθε φάση του γύρου με τη σειρά που έγιναν sort, και όταν έχουν παίξει όλοι στη συγκεκριμένη φάση το παιχνίδι συνεχίζει στην επόμενη.
Στην εκτύπωση του χεριού του κάθε παίκτη, δίπλα απο την κάρτα μέσα σε παρένθεση εκτυπώνεται το κόστος της.
Όταν εκτυπώνεται ο στρατός του κάθε παίκτη, μετά το όνομα της κάθε κάρτας εκτυπωνεται σε παρένθεση αν η κάρτα είναι tapped (T) ή όχι (UnT).
Σε επαναλήψεις και συνθήκες που ο παίκτης χρειάζεται να διαλέγει απο καμία, μία έως πολλές κάρτες, inputs εκτός απο αυτών που αναφέρονται στο σχετικό μήνυμα θα οδηγήσουν σε λάθος κατά την εκτέλεση του προγράμματος.
Γενικά, για να βγεί απο τις επαναλήψεις, μόνο τις επαναλήψεις, ένας παίκτης βάζει input 0, ακόμα και αν δεν έχει διαλέξει κάποια κάρτα σε αυτήν την επανάληψη, πχ στην Equip Phase που διαλέγει να αγοράσει πράσινες κάρτες.
Στη φάση μάχης, πρώτα όλοι οι παίκτες διαλέγουν αν θα αμυνθούν τις επαρχίες τους ή όχι κάνοντας tap τις αντίστοιχες προσωπικότητες του στρατού τους(η προσωπικότητα μπορεί να χρησιμοποιηθεί μόνο για άμυνα αυτόν το γύρο)
και στη συνέχεια δίνεται η δυνατότητα στον κάθε παίκτη να επιλέξει αν θα επιτεθεί, ποιες προσωπικότητες θα χρησιμοποιήσει(μπορούν να χρησιμοποιηθούν μόνο για επίθεση αυτό το γύρο), κάνοντάς τες tap,  
και τέλος σε ποιον παίκτη και σε ποια επαρχία του θα κάνει την επίθεση. Ισχύουν όλες οι προδιαγραφές που αναφέρονται στην εκφώνηση για την φάση μάχης.
Στην εκτύπωση των επαρχιών δίπλα απο το όνομα της επαρχίας εκτυπώνεται σε παρένθεση τo (R) όταν η επαρχία είναι revealed και (NR) όταν δεν είναι. 
Όταν αγοράζεται μια επαρχία απο τον παίκτη, η μαύρη κάρτα που τραβάει για να την αντικαταστήσει εισέρχεται στο τέλος του vector όπου αποθηκεύονται οι επαρχίες του παίκτη και δεν μπορεί να αγοραστεί σε αυτόν το γύρο εφόσον είναι (NR).
Στην τελική φάση έχουν υλοποιηθεί οι συναρτήσεις που ζητούνται, με την printArena() να εκτυπώνει τον στρατό του κάθε παίκτη(με μία ακόμα παρένθεση που περιέχει τους πόντους επίθεσης της προσωπικότητας) 
και στη συνέχεια τυχόν ακολούθους ή/και αντικείμενα που έχει η κάθε προσωπικότητα. Η printGameStatistics() είναι περιττή, εφόσον οι υλοποιημένες συναρτήσεις για αυτή τη φάση καλύπτουν τις ανάγκες των παικτών.
Στο τέλος της final Phase εκτελείται η checkWinningCondition() για να δεί αν κάποιος παίκτης έχει νικήσει το παιχνίδι. Αν όντως κάποιος παίκτης έχει βγει νικητής το παιχνίδι τελειώνει και σταματά η εκτέλεση του προγράμματος.
Γενικά στις κλάσεις, όταν αποθηκεύονται οι πληροφορίες πολλών καρτών του ίδιου είδους, χρησιμοποιούνται vectors(πχ ο στρατός του κάθε παίκτη, οι ακόλουθοι κάθε προσωπικότητας, τα αντικείμενα κάθε προσωπικότητας, κοκ).
Επίσης χρησιμοποιούνται αρκετές bool μεταβλητές μέσα στις κλάσεις οι οποίες αποδίδουν μια ιδιότητα του αντικειμένου μέσα στο παιχνίδι(πχ στις προσωπικότητες η bool isDefending όταν η προσωπικότητα χρησιμοποιείται για άμυνα, isAttacking όταν επιτίθεται κοκ).
Η χρήση των bool ήταν ακήμα πιο χρήσιμη στην αναγνώριση της κάρτας(isMine για να δεις αν ένα holding είναι Mine) με τις οποίες αντικαταστήσαμε το δεύτερο όρισμα (int) που όριζε η εκφώνηση να βάλουμε στον constructor των καρτών.	.
Στην δημιουργία μιας αλυσίδας το upperHolding ενος Mine μπορεί να είναι μόνο GoldMine και το subHolding ενος CrystalMine μπορεί να είναι μόνο GoldMine.
